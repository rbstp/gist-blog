<section class="graph-page">
  <div class="graph-page-canvas">
    <button class="graph-reset-btn" data-target="global-tag-graph" title="Reset view">reset</button>
    <svg id="global-tag-graph" class="graph-svg" viewBox="0 0 800 520" width="800" height="520"
      aria-label="Global tag graph"></svg>
  </div>

  <div class="hero-terminal">
    <div class="terminal-window">
      <div class="terminal-header">
        <div class="terminal-controls">
          <span class="control close"></span>
          <span class="control minimize"></span>
          <span class="control maximize"></span>
        </div>
        <div class="terminal-title"></div>
      </div>
      <div class="terminal-body">
        <div class="terminal-line">
          <span class="prompt">rbstp@devops:~$</span>
          <span class="command">man graph</span>
        </div>
        <div class="terminal-output">
          <pre class="output-text" aria-label="man page for graph" style="margin: .25rem 0 0;">GRAPH(1)                           User Commands                           GRAPH(1)

NAME
    graph - interactive tag graph viewer for the blog

SYNOPSIS
    graph [--global] [--tags] | view

DESCRIPTION
    Renders an interactive graph of tags across all posts.
    Scroll to zoom, drag to pan. Hover to highlight neighbors.
    Click a tag to filter posts on the homepage.
          </pre>
        </div>

        <!-- Easter egg: revealed when the terminal is maximized (same behavior as whoami on index) -->
        <div id="hero-terminal-expanded" style="display: none;">
          <div class="terminal-line">
            <span class="prompt">rbstp@devops:~$</span>
            <span class="command">graph --stats</span>
          </div>
          <div class="terminal-output">
            <span class="output-text">nodes: <span id="ee-nodes">…</span>, edges: <span id="ee-edges">…</span></span>
          </div>
          <div class="terminal-line">
            <span class="prompt">rbstp@devops:~$</span>
            <span class="command">grep -E 'top|pair' tags.log</span>
          </div>
          <div class="terminal-output">
            <span class="output-text">top tag: <span id="ee-top-tag">…</span> • top pair: <span
                id="ee-top-pair">…</span></span>
          </div>
          <div class="terminal-line">
            <span class="prompt">rbstp@devops:~$</span>
            <span class="command">kubectl get deploy -n platform</span>
          </div>
          <div class="terminal-output">
            <pre class="output-text" style="margin: .25rem 0 0;">NAME                 READY   UP-TO-DATE   AVAILABLE   AGE
tag-graph            1/1     1            1           42d
feed-generator       1/1     1            1           42d
static-site          1/1     1            1           42d
content-indexer      1/1     1            1           42d
            </pre>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<script>
  (function () {
    function navigateWithTag(tag) {
      try { localStorage.setItem('preselectedTags', JSON.stringify([tag])); } catch { }
      window.location.href = '/';
    }

    // Pan/zoom util that returns helpers used by dragging
    function enablePanZoom(svg, root, options = {}) {
      let scale = 1, tx = 0, ty = 0; let panning = false; let lastX = 0, lastY = 0;
      let dragCandidate = false; const DRAG_THRESHOLD = 4;
      const pointers = new Map(); let pinch = null; let lastTapTime = 0;
      let initialScale = 1, initialTx = 0, initialTy = 0;

      function apply() { root.setAttribute('transform', `scale(${scale}) translate(${tx},${ty})`); }
      function clientToViewBox(cx, cy) {
        const rect = svg.getBoundingClientRect();
        const vb = svg.viewBox?.baseVal || { x: 0, y: 0, width: svg.width.baseVal.value, height: svg.height.baseVal.value };
        return { x: vb.x + ((cx - rect.left) / rect.width) * vb.width, y: vb.y + ((cy - rect.top) / rect.height) * vb.height };
      }
      function toWorldDelta(c0x, c0y, c1x, c1y) {
        const p0 = clientToViewBox(c0x, c0y), p1 = clientToViewBox(c1x, c1y);
        return { dx: (p1.x - p0.x) / scale, dy: (p1.y - p0.y) / scale };
      }
      function clampPan() {
        const vb = svg.viewBox?.baseVal || { x: 0, y: 0, width: svg.width.baseVal.value, height: svg.height.baseVal.value };
        const bleed = 0.4; const minX = -vb.width * bleed, minY = -vb.height * bleed, maxX = vb.width * bleed, maxY = vb.height * bleed;
        tx = Math.max(minX, Math.min(maxX, tx)); ty = Math.max(minY, Math.min(maxY, ty));
      }
      function tryStartPinch() {
        if (pointers.size !== 2 || pinch) return;
        const pts = Array.from(pointers.values());
        const mx = (pts[0].x + pts[1].x) / 2, my = (pts[0].y + pts[1].y) / 2;
        const dx = pts[0].x - pts[1].x, dy = pts[0].y - pts[1].y; const d0 = Math.hypot(dx, dy) || 1;
        const midVB = clientToViewBox(mx, my);
        const world = { x: (midVB.x - tx) / scale, y: (midVB.y - ty) / scale };
        pinch = { s0: scale, t0: { x: tx, y: ty }, d0, world }; panning = false;
      }
      function updatePinch() {
        if (!pinch || pointers.size !== 2) return;
        const pts = Array.from(pointers.values());
        const mx = (pts[0].x + pts[1].x) / 2, my = (pts[0].y + pts[1].y) / 2;
        const dx = pts[0].x - pts[1].x, dy = pts[0].y - pts[1].y; const d = Math.hypot(dx, dy) || 1;
        let next = pinch.s0 * (d / pinch.d0); next = Math.max(0.4, Math.min(2.5, next));
        const midVB = clientToViewBox(mx, my);
        tx = midVB.x - next * pinch.world.x; ty = midVB.y - next * pinch.world.y; scale = next; apply();
      }
      svg.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        const old = scale; const next = Math.max(0.4, Math.min(2.5, old * factor));
        if (next === old) return;
        const { x: px, y: py } = clientToViewBox(e.clientX, e.clientY);
        const ratio = next / old;
        tx = px - ratio * (px - tx); ty = py - ratio * (py - ty);
        scale = next; apply();
      }, { passive: false });
      svg.addEventListener('pointerdown', (e) => {
        pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        if (pointers.size === 1) {
          const now = performance.now();
          if (now - lastTapTime < 300) {
            const { x: px, y: py } = clientToViewBox(e.clientX, e.clientY);
            const old = scale; const next = Math.max(0.4, Math.min(2.5, old * 1.6));
            const ratio = next / old; tx = px - ratio * (px - tx); ty = py - ratio * (py - ty);
            scale = next; apply(); lastTapTime = 0;
          } else { lastTapTime = now; }
          dragCandidate = true; panning = false; lastX = e.clientX; lastY = e.clientY;
        } else if (pointers.size === 2) { tryStartPinch(); }
      });
      svg.addEventListener('pointermove', (e) => {
        if (pointers.has(e.pointerId)) pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        if (pinch) { updatePinch(); return; }
        const p0 = clientToViewBox(lastX, lastY), p1 = clientToViewBox(e.clientX, e.clientY);
        const dx = p1.x - p0.x, dy = p1.y - p0.y;
        if (dragCandidate && !panning) {
          const moved = Math.hypot(e.clientX - lastX, e.clientY - lastY);
          if (moved > DRAG_THRESHOLD) { panning = true; dragCandidate = false; svg.setPointerCapture?.(e.pointerId); svg.classList.add('panning'); }
          else return;
        }
        lastX = e.clientX; lastY = e.clientY; if (!panning) return;
        tx += dx; ty += dy; clampPan(); apply();
      });
      function endInteraction(e) {
        if (pointers.has(e.pointerId)) pointers.delete(e.pointerId);
        if (pointers.size < 2) pinch = null;
        if (pointers.size === 0) { dragCandidate = false; panning = false; svg.classList.remove('panning'); }
      }
      svg.addEventListener('pointerup', endInteraction); svg.addEventListener('pointercancel', endInteraction);
      svg.addEventListener('pointerleave', () => { panning = false; svg.classList.remove('panning'); });

      // Wire camera reset (layout reset will be wired separately in renderGlobalGraph)
      const resetButtons = document.querySelectorAll('.graph-reset-btn');
      resetButtons.forEach(btn => {
        const targetId = btn.getAttribute('data-target');
        if (targetId === svg.id) {
          btn.addEventListener('click', () => { scale = initialScale; tx = initialTx; ty = initialTy; apply(); });
        }
      });

      // Optionally fit content to the viewBox on first load
      function fitToContent(padding = 24) {
        try {
          const vb = svg.viewBox?.baseVal || { x: 0, y: 0, width: svg.width.baseVal.value, height: svg.height.baseVal.value };
          const bbox = root.getBBox();
          if (!bbox || !isFinite(bbox.width) || !isFinite(bbox.height) || bbox.width === 0 || bbox.height === 0) { apply(); return; }
          const contentW = bbox.width + 2 * padding, contentH = bbox.height + 2 * padding;
          const s = Math.min(vb.width / contentW, vb.height / contentH);
          scale = Math.max(0.3, Math.min(2.5, s));
          const cx = vb.x + vb.width / 2, cy = vb.y + vb.height / 2;
          const ccx = bbox.x + bbox.width / 2, ccy = bbox.y + bbox.height / 2;
          tx = cx - scale * ccx; ty = cy - scale * ccy;
          initialScale = scale; initialTx = tx; initialTy = ty; apply();
        } catch { }
      }
      if (options.autoFit) requestAnimationFrame(() => fitToContent(options.padding ?? 24));
      apply();
      return { clientToViewBox, toWorldDelta, getScale: () => scale };
    }

    function renderGlobalGraph() {
      const svg = document.getElementById('global-tag-graph');
      if (!svg) return;

      fetch('/graph.json?v={{timestamp}}')
        .then(r => r.ok ? r.json() : null)
        .then(graph => {
          if (!graph || !graph.nodes) {
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', '50%'); t.setAttribute('y', '50%'); t.setAttribute('text-anchor', 'middle'); t.textContent = 'No graph data'; t.setAttribute('class', 'graph-empty'); svg.appendChild(t); return;
          }

          // Easter egg stats (unchanged)
          try {
            const nodesEl = document.getElementById('ee-nodes');
            const edgesEl = document.getElementById('ee-edges');
            const topTagEl = document.getElementById('ee-top-tag');
            const topPairEl = document.getElementById('ee-top-pair');
            const tfNodes1 = document.getElementById('ee-tf-nodes');
            const tfEdges1 = document.getElementById('ee-tf-edges');
            const tfNodes2 = document.getElementById('ee-tf-nodes2');
            const tfEdges2 = document.getElementById('ee-tf-edges2');
            const sloEl = document.getElementById('ee-slo');
            const ebEl = document.getElementById('ee-eb');
            if (nodesEl) nodesEl.textContent = String(graph.nodes.length);
            if (edgesEl) edgesEl.textContent = String(graph.edges.length);
            if (topTagEl) {
              const topNode = graph.nodes.slice().sort((a, b) => (b.count || 0) - (a.count || 0))[0];
              topTagEl.textContent = topNode ? `#${topNode.id}` : 'n/a';
            }
            if (topPairEl) {
              const topEdge = graph.edges.slice().sort((a, b) => (b.weight || 0) - (a.weight || 0))[0];
              topPairEl.textContent = topEdge ? `#${topEdge.source} + #${topEdge.target}` : 'n/a';
            }
            const n = graph.nodes.length, e = graph.edges.length;
            if (tfNodes1) tfNodes1.textContent = String(n);
            if (tfEdges1) tfEdges1.textContent = String(e);
            if (tfNodes2) tfNodes2.textContent = String(n);
            if (tfEdges2) tfEdges2.textContent = String(e);
            const density = n > 1 ? Math.min(1, (2 * e) / (n * (n - 1))) : 0;
            const slo = (99.5 + 0.49 * density).toFixed(2) + '%';
            const eb = Math.max(0.01, 1 - (parseFloat(slo) / 100)).toFixed(2) + '%';
            if (sloEl) sloEl.textContent = slo;
            if (ebEl) ebEl.textContent = eb;
          } catch { }

          const width = 800, height = 520, cx = width / 2, cy = height / 2;
          svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
          while (svg.firstChild) svg.removeChild(svg.firstChild);
          const root = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          root.setAttribute('id', 'global-graph-root');
          svg.appendChild(root);

          const pz = enablePanZoom(svg, root, { autoFit: true, padding: 28 });

          // Layout
          const nodes = graph.nodes.slice().sort((a, b) => b.count - a.count);
          const maxCount = Math.max(1, ...nodes.map(n => n.count));
          const ringRadius = [0, 120, 200, 280];
          const perRing = [1, 6, 8, 12];

          const positions = new Map();   // id -> {x,y}
          const nodeRefs = new Map();    // id -> {g,circle,text,radius}
          const neighbors = new Map();   // id -> Set(neighborId)
          function addNeighbor(a, b) { if (!neighbors.has(a)) neighbors.set(a, new Set()); neighbors.get(a).add(b); }

          let idx = 0;
          for (let r = 0; r < ringRadius.length; r++) {
            const radius = ringRadius[r];
            const nThisRing = perRing[r];
            for (let i = 0; i < nThisRing && idx < nodes.length; i++, idx++) {
              const angle = (i / Math.max(1, nThisRing)) * Math.PI * 2 - Math.PI / 2;
              positions.set(nodes[idx].id, { x: cx + (r === 0 ? 0 : radius * Math.cos(angle)), y: cy + (r === 0 ? 0 : radius * Math.sin(angle)) });
            }
          }

          // Keep a pristine copy for layout reset
          const initialPositions = new Map();
          positions.forEach((p, id) => initialPositions.set(id, { x: p.x, y: p.y }));

          const linkMap = new Map();
          const maxWeight = Math.max(1, ...graph.edges.map(e => e.weight || 1));
          graph.edges.forEach(e => {
            addNeighbor(e.source, e.target); addNeighbor(e.target, e.source);
            const p1 = positions.get(e.source), p2 = positions.get(e.target);
            if (!p1 || !p2) return;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y);
            line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
            line.setAttribute('class', 'graph-link');
            line.setAttribute('stroke-width', String(0.5 + 1.5 * ((e.weight || 1) / maxWeight)));
            root.appendChild(line);
            const key = e.source < e.target ? `${e.source}|${e.target}` : `${e.target}|${e.source}`;
            linkMap.set(key, line);
          });

          function updateEdgesForNode(id) {
            const set = neighbors.get(id) || new Set();
            set.forEach(nid => {
              const p1 = positions.get(id), p2 = positions.get(nid);
              if (!p1 || !p2) return;
              const key = id < nid ? `${id}|${nid}` : `${nid}|${id}`;
              const line = linkMap.get(key);
              if (line) { line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y); line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y); }
            });
          }
          function setNodePosition(id, x, y) {
            positions.set(id, { x, y });
            const ref = nodeRefs.get(id);
            if (ref) {
              ref.circle.setAttribute('cx', x); ref.circle.setAttribute('cy', y);
              ref.text.setAttribute('x', String(x + ref.radius + 2)); ref.text.setAttribute('y', String(y + 3));
            }
            updateEdgesForNode(id);
          }
          function moveNodeAndNeighbors(id, dx, dy, factor = 0.25) {
            const p = positions.get(id);
            if (p) setNodePosition(id, p.x + dx, p.y + dy);
            const neigh = neighbors.get(id);
            if (neigh) neigh.forEach(nid => {
              const pn = positions.get(nid); if (pn) setNodePosition(nid, pn.x + dx * factor, pn.y + dy * factor);
            });
          }

          // Update terminal title with live stats
            try {
              const titleEl = document.querySelector('.terminal-title');
              if (titleEl) {
                const n = graph.nodes?.length || 0;
                const e = graph.edges?.length || 0;
                titleEl.textContent = `graph • ${n} nodes • ${e} edges`;
              }
            } catch {}

          // Draw nodes + interactions
          nodes.forEach(n => {
            const { x, y } = positions.get(n.id) || { x: cx, y: cy };
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'graph-node'); g.setAttribute('data-id', n.id);
            g.setAttribute('role', 'button');
            g.setAttribute('tabindex', '0');
            g.setAttribute('aria-label', `Open tag ${n.id}`);
            const r = 4 + 8 * (n.count / maxCount);
            const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            c.setAttribute('cx', x); c.setAttribute('cy', y); c.setAttribute('r', String(r));
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', String(x + r + 2)); t.setAttribute('y', String(y + 3)); t.textContent = n.id;
            g.appendChild(c); g.appendChild(t); root.appendChild(g);
            nodeRefs.set(n.id, { g, circle: c, text: t, radius: r });

            g.addEventListener('mouseenter', () => highlight(n.id));
            g.addEventListener('mouseleave', () => { if (!isDraggingNode) clear(); });

            // Dragging
            let startClient = { x: 0, y: 0 }, lastClient = { x: 0, y: 0 }, movedVb = 0;
            const SUPPRESS_AFTER_VB = 3;
            g.addEventListener('pointerdown', (e) => {
              e.stopPropagation(); e.preventDefault();
              isDraggingNode = true; svg.classList.add('dragging-node'); g.classList.add('dragging');
              startClient = { x: e.clientX, y: e.clientY }; lastClient = { x: e.clientX, y: e.clientY }; movedVb = 0;
              g.setPointerCapture?.(e.pointerId);
            });
            g.addEventListener('pointermove', (e) => {
              if (!isDraggingNode) return; e.stopPropagation(); e.preventDefault();
              const { dx, dy } = pz.toWorldDelta(lastClient.x, lastClient.y, e.clientX, e.clientY);
              lastClient = { x: e.clientX, y: e.clientY };
              const vb0 = pz.clientToViewBox(startClient.x, startClient.y);
              const vb1 = pz.clientToViewBox(e.clientX, e.clientY);
              movedVb = Math.max(movedVb, Math.hypot(vb1.x - vb0.x, vb1.y - vb0.y));
              if (dx || dy) moveNodeAndNeighbors(n.id, dx, dy, 0.25);
            });
            function endDrag(e) {
              if (!isDraggingNode) return; e.stopPropagation(); e.preventDefault();
              isDraggingNode = false; g.releasePointerCapture?.(e.pointerId); svg.classList.remove('dragging-node'); g.classList.remove('dragging');
              if (movedVb > SUPPRESS_AFTER_VB) { blockClickNav = true; setTimeout(() => { blockClickNav = false; }, 0); }
            }
            g.addEventListener('pointerup', endDrag); g.addEventListener('pointercancel', endDrag);

            // Click to navigate (blocked right after a drag)
            g.addEventListener('click', (e) => { if (blockClickNav) { e.stopPropagation(); e.preventDefault(); return; } navigateWithTag(n.id); });
            g.addEventListener('keydown', (e) => {
              if (blockClickNav) return;
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                navigateWithTag(n.id);
              }
            });
          });

          // Highlight helpers
          function highlight(id) {
            const neigh = new Set([id]);
            graph.edges.forEach(e => { if (e.source === id) neigh.add(e.target); if (e.target === id) neigh.add(e.source); });
            root.querySelectorAll('.graph-node').forEach(el => {
              const nid = el.getAttribute('data-id'); const active = neigh.has(nid);
              el.classList.toggle('active', active); el.classList.toggle('dimmed', !active);
            });
            root.querySelectorAll('.graph-link').forEach(l => l.classList.add('dimmed'));
            graph.edges.forEach(e => {
              if (e.source === id || e.target === id || neigh.has(e.source) || neigh.has(e.target)) {
                const key = e.source < e.target ? `${e.source}|${e.target}` : `${e.target}|${e.source}`;
                const line = linkMap.get(key); if (line) line.classList.remove('dimmed');
              }
            });
          }
          function clear() {
            root.querySelectorAll('.graph-node').forEach(el => el.classList.remove('active', 'dimmed'));
            root.querySelectorAll('.graph-link').forEach(el => el.classList.remove('dimmed'));
          }

          // Layout reset wiring (in addition to camera reset already wired in enablePanZoom)
          const resetBtn = document.querySelector('.graph-reset-btn[data-target="global-tag-graph"]');
          if (resetBtn) {
            resetBtn.addEventListener('click', () => {
              // Restore all node positions to their initial layout
              initialPositions.forEach((p, id) => setNodePosition(id, p.x, p.y));
              clear(); // remove highlight/dim states
            });
          }

          // Drag state flags
          let isDraggingNode = false;
          let blockClickNav = false;
        })
        .catch(() => {
          const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          t.setAttribute('x', '50%'); t.setAttribute('y', '50%'); t.setAttribute('text-anchor', 'middle'); t.textContent = 'Failed to load graph.json'; t.setAttribute('class', 'graph-empty'); svg.appendChild(t);
        });
    }

    document.addEventListener('DOMContentLoaded', renderGlobalGraph);
  })();

  // Update terminal title with live stats
  try {
    const titleEl = document.querySelector('.terminal-title');
    if (titleEl) {
      const n = graph.nodes?.length || 0;
      const e = graph.edges?.length || 0;
      titleEl.textContent = `graph • ${n} nodes • ${e} edges`;
    }
  } catch {}
</script>
