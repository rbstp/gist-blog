<section class="graph-page">
  <div class="graph-page-canvas">
    <button class="graph-reset-btn" data-target="global-tag-graph" title="Reset view">reset</button>
    <svg id="global-tag-graph" class="graph-svg" viewBox="0 0 800 520" width="800" height="520"
      aria-label="Global tag graph"></svg>
  </div>

  <div class="hero-terminal">
    <div class="terminal-window">
      <div class="terminal-header">
        <div class="terminal-controls">
          <span class="control close"></span>
          <span class="control minimize"></span>
          <span class="control maximize"></span>
        </div>
        <div class="terminal-title"></div>
      </div>
      <div class="terminal-body">
        <div class="terminal-line">
          <span class="prompt">rbstp@devops:~$</span>
          <span class="command">man graph</span>
        </div>
        <div class="terminal-output">
          <pre class="output-text" aria-label="man page for graph" style="margin: .25rem 0 0;">GRAPH(1)                           User Commands                           GRAPH(1)

NAME
    graph - interactive tag graph viewer for the blog

SYNOPSIS
    graph [--global] [--tags] | view

DESCRIPTION
    Renders an interactive graph of tags across all posts.
    Scroll to zoom, drag to pan. Hover to highlight neighbors.
    Click a tag to filter posts on the homepage.
          </pre>
        </div>

        <!-- Easter egg: revealed when the terminal is maximized (same behavior as whoami on index) -->
        <div id="hero-terminal-expanded" style="display: none;">
          <div class="terminal-line">
            <span class="prompt">rbstp@devops:~$</span>
            <span class="command">graph --stats</span>
          </div>
          <div class="terminal-output">
            <span class="output-text">nodes: <span id="ee-nodes">…</span>, edges: <span id="ee-edges">…</span></span>
          </div>
          <div class="terminal-line">
            <span class="prompt">rbstp@devops:~$</span>
            <span class="command">grep -E 'top|pair' tags.log</span>
          </div>
          <div class="terminal-output">
            <span class="output-text">top tag: <span id="ee-top-tag">…</span> • top pair: <span
                id="ee-top-pair">…</span></span>
          </div>
          <div class="terminal-line">
            <span class="prompt">rbstp@devops:~$</span>
            <span class="command">kubectl get deploy -n platform</span>
          </div>
          <div class="terminal-output">
            <pre class="output-text" style="margin: .25rem 0 0;">NAME                 READY   UP-TO-DATE   AVAILABLE   AGE
tag-graph            1/1     1            1           42d
feed-generator       1/1     1            1           42d
static-site          1/1     1            1           42d
content-indexer      1/1     1            1           42d
            </pre>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<script>
  (function () {
    function navigateWithTag(tag) {
      try { localStorage.setItem('preselectedTags', JSON.stringify([tag])); } catch { }
      window.location.href = '/';
    }

    function enablePanZoom(svg, root, options = {}) {
      let scale = 1, tx = 0, ty = 0; let panning = false; let lastX = 0, lastY = 0;
      let dragCandidate = false; const DRAG_THRESHOLD = 4; let downOnNode = false;
      const pointers = new Map();
      let pinch = null; // {s0,t0:{x,y},d0,world:{x,y}}
      let lastTapTime = 0;
      // Remember the fitted "home" view so reset restores it
      let initialScale = 1, initialTx = 0, initialTy = 0;
      function apply() { root.setAttribute('transform', `scale(${scale}) translate(${tx},${ty})`); }
      function clientToViewBox(cx, cy) {
        const rect = svg.getBoundingClientRect();
        const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : { x: 0, y: 0, width: svg.width.baseVal.value, height: svg.height.baseVal.value };
        return { x: vb.x + ((cx - rect.left) / rect.width) * vb.width, y: vb.y + ((cy - rect.top) / rect.height) * vb.height };
      }
      function clampPan() {
        const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : { x: 0, y: 0, width: svg.width.baseVal.value, height: svg.height.baseVal.value };
        const bleed = 0.4; const minX = -vb.width * bleed, minY = -vb.height * bleed, maxX = vb.width * bleed, maxY = vb.height * bleed;
        tx = Math.max(minX, Math.min(maxX, tx)); ty = Math.max(minY, Math.min(maxY, ty));
      }
      function tryStartPinch() {
        if (pointers.size !== 2 || pinch) return;
        const pts = Array.from(pointers.values());
        const mx = (pts[0].x + pts[1].x) / 2, my = (pts[0].y + pts[1].y) / 2;
        const dx = pts[0].x - pts[1].x, dy = pts[0].y - pts[1].y; const d0 = Math.hypot(dx, dy) || 1;
        const midVB = clientToViewBox(mx, my);
        const world = { x: (midVB.x - tx) / scale, y: (midVB.y - ty) / scale };
        pinch = { s0: scale, t0: { x: tx, y: ty }, d0, world }; panning = false;
      }
      function updatePinch() {
        if (!pinch || pointers.size !== 2) return;
        const pts = Array.from(pointers.values());
        const mx = (pts[0].x + pts[1].x) / 2, my = (pts[0].y + pts[1].y) / 2;
        const dx = pts[0].x - pts[1].x, dy = pts[0].y - pts[1].y; const d = Math.hypot(dx, dy) || 1;
        let next = pinch.s0 * (d / pinch.d0); next = Math.max(0.4, Math.min(2.5, next));
        const midVB = clientToViewBox(mx, my);
        tx = midVB.x - next * pinch.world.x; ty = midVB.y - next * pinch.world.y; scale = next; apply();
      }
      svg.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        const old = scale;
        const next = Math.max(0.4, Math.min(2.5, old * factor));
        if (next === old) return;
        const { x: px, y: py } = clientToViewBox(e.clientX, e.clientY);
        // Keep the world point under the cursor fixed using scale-then-translate formula
        const ratio = next / old;
        tx = px - ratio * (px - tx);
        ty = py - ratio * (py - ty);
        scale = next;
        apply();
      }, { passive: false });
      svg.addEventListener('pointerdown', (e) => {
        pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        if (pointers.size === 1) {
          // detect double-tap
          const now = performance.now();
          if (now - lastTapTime < 300) {
            const { x: px, y: py } = clientToViewBox(e.clientX, e.clientY);
            const old = scale; const next = Math.max(0.4, Math.min(2.5, old * 1.6));
            const ratio = next / old;
            tx = px - ratio * (px - tx);
            ty = py - ratio * (py - ty);
            scale = next;
            apply();
            lastTapTime = 0;
          } else {
            lastTapTime = now;
          }
          // don't start panning yet; wait for small movement to avoid stealing clicks
          dragCandidate = true; panning = false; lastX = e.clientX; lastY = e.clientY;
          downOnNode = !!(e.target && e.target.closest && e.target.closest('.graph-node'));
          // do not setPointerCapture yet; only when we confirm drag in pointermove
        } else if (pointers.size === 2) { tryStartPinch(); }
      });
      svg.addEventListener('pointermove', (e) => {
        if (pointers.has(e.pointerId)) pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        if (pinch) { updatePinch(); return; }
        const p0 = clientToViewBox(lastX, lastY);
        const p1 = clientToViewBox(e.clientX, e.clientY);
        const dx = p1.x - p0.x; const dy = p1.y - p0.y;
        if (dragCandidate && !panning) {
          // start panning only after threshold to preserve clicks
          const moved = Math.hypot(e.clientX - lastX, e.clientY - lastY);
          if (Math.hypot(dx, dy) > DRAG_THRESHOLD * (svg.viewBox?.baseVal?.width || 800) / (svg.getBoundingClientRect().width || 1)) {
            panning = true; dragCandidate = false; svg.setPointerCapture?.(e.pointerId); svg.classList.add('panning');
          } else {
            return; // ignore tiny movement until pan starts
          }
        }
        lastX = e.clientX; lastY = e.clientY;
        if (!panning) return;
        tx += dx; ty += dy; clampPan(); apply();
      });
      function endInteraction(e) {
        if (pointers.has(e.pointerId)) pointers.delete(e.pointerId);
        if (pointers.size < 2) pinch = null;
        if (pointers.size === 0) {
          // if we never started panning, allow clicks to go through naturally
          dragCandidate = false; downOnNode = false; panning = false; svg.classList.remove('panning');
        }
      }
      svg.addEventListener('pointerup', endInteraction); svg.addEventListener('pointercancel', endInteraction); svg.addEventListener('pointerleave', (e) => { panning = false; svg.classList.remove('panning'); });
      // Delegated click fallback: in case pointer capture retargets events, ensure node clicks still navigate
      root.addEventListener('click', (e) => {
        if (panning) return; // don't navigate on drag
        const node = e.target && e.target.closest ? e.target.closest('.graph-node') : null;
        const id = node && node.getAttribute('data-id');
        if (id) navigateWithTag(id);
      });
      // Wire reset button
      const resetButtons = document.querySelectorAll('.graph-reset-btn');
      resetButtons.forEach(btn => {
        const targetId = btn.getAttribute('data-target');
        if (targetId === svg.id) {
          btn.addEventListener('click', () => { scale = initialScale; tx = initialTx; ty = initialTy; apply(); });
        }
      });

      // Optionally fit content to the viewBox on first load
      function fitToContent(padding = 24) {
        try {
          const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : { x: 0, y: 0, width: svg.width.baseVal.value, height: svg.height.baseVal.value };
          const bbox = root.getBBox();
          if (!bbox || !isFinite(bbox.width) || !isFinite(bbox.height) || bbox.width === 0 || bbox.height === 0) { apply(); return; }
          const contentW = bbox.width + 2 * padding;
          const contentH = bbox.height + 2 * padding;
          const s = Math.min(vb.width / contentW, vb.height / contentH);
          // Keep scale in bounds but allow slight upscale if content is tiny
          scale = Math.max(0.3, Math.min(2.5, s));
          const cx = vb.x + vb.width / 2; const cy = vb.y + vb.height / 2;
          const ccx = bbox.x + bbox.width / 2; const ccy = bbox.y + bbox.height / 2;
          tx = cx - scale * ccx; ty = cy - scale * ccy;
          initialScale = scale; initialTx = tx; initialTy = ty;
          apply();
        } catch { /* ignore */ }
      }

      // Defer fit until DOM paints so bbox is accurate
      if (options.autoFit) { requestAnimationFrame(() => fitToContent(options.padding ?? 24)); }
      apply();
    }

    function renderGlobalGraph() {
      const svg = document.getElementById('global-tag-graph');
      if (!svg) return;

      fetch('/graph.json?v={{timestamp}}')
        .then(r => r.ok ? r.json() : null)
        .then(graph => {
          if (!graph || !graph.nodes) {
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', '50%'); t.setAttribute('y', '50%'); t.setAttribute('text-anchor', 'middle'); t.textContent = 'No graph data'; t.setAttribute('class', 'graph-empty'); svg.appendChild(t); return;
          }

          // Populate easter egg stats if the expanded terminal is present
          try {
            const nodesEl = document.getElementById('ee-nodes');
            const edgesEl = document.getElementById('ee-edges');
            const topTagEl = document.getElementById('ee-top-tag');
            const topPairEl = document.getElementById('ee-top-pair');
            // DevOps-themed placeholders
            const tfNodes1 = document.getElementById('ee-tf-nodes');
            const tfEdges1 = document.getElementById('ee-tf-edges');
            const tfNodes2 = document.getElementById('ee-tf-nodes2');
            const tfEdges2 = document.getElementById('ee-tf-edges2');
            const sloEl = document.getElementById('ee-slo');
            const ebEl = document.getElementById('ee-eb');
            if (nodesEl) nodesEl.textContent = String(graph.nodes.length);
            if (edgesEl) edgesEl.textContent = String(graph.edges.length);
            if (topTagEl) {
              const topNode = graph.nodes.slice().sort((a, b) => (b.count || 0) - (a.count || 0))[0];
              topTagEl.textContent = topNode ? `#${topNode.id}` : 'n/a';
            }
            if (topPairEl) {
              const topEdge = graph.edges.slice().sort((a, b) => (b.weight || 0) - (a.weight || 0))[0];
              topPairEl.textContent = topEdge ? `#${topEdge.source} + #${topEdge.target}` : 'n/a';
            }

            // Fill Terraform-style diff numbers (pretend nodes/edges drift then reconcile)
            const n = graph.nodes.length;
            const e = graph.edges.length;
            if (tfNodes1) tfNodes1.textContent = String(n);
            if (tfEdges1) tfEdges1.textContent = String(e);
            if (tfNodes2) tfNodes2.textContent = String(n); // zero-drift target
            if (tfEdges2) tfEdges2.textContent = String(e);

            // Derive a playful SLO/EB from density
            const density = n > 1 ? Math.min(1, (2 * e) / (n * (n - 1))) : 0;
            // Map density to SLO in [99.5, 99.99]
            const slo = (99.5 + 0.49 * density).toFixed(2) + '%';
            const eb = Math.max(0.01, 1 - (parseFloat(slo) / 100)).toFixed(2) + '%';
            if (sloEl) sloEl.textContent = slo;
            if (ebEl) ebEl.textContent = eb;
          } catch { }

          // Simple radial layout around center
          const width = 800, height = 520, cx = width / 2, cy = height / 2;
          svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
          while (svg.firstChild) svg.removeChild(svg.firstChild);
          const root = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          root.setAttribute('id', 'global-graph-root');
          svg.appendChild(root);

          // Order nodes by count and arrange in concentric rings
          const nodes = graph.nodes.slice().sort((a, b) => b.count - a.count);
          const maxCount = Math.max(1, ...nodes.map(n => n.count));
          const ringRadius = [0, 120, 200, 280];
          const perRing = [1, 6, 8, 12];
          const positions = new Map();
          let idx = 0;
          for (let r = 0; r < ringRadius.length; r++) {
            const radius = ringRadius[r];
            const nThisRing = perRing[r];
            for (let i = 0; i < nThisRing && idx < nodes.length; i++, idx++) {
              const angle = (i / Math.max(1, nThisRing)) * Math.PI * 2 - Math.PI / 2;
              positions.set(nodes[idx].id, { x: cx + (r === 0 ? 0 : radius * Math.cos(angle)), y: cy + (r === 0 ? 0 : radius * Math.sin(angle)) });
            }
          }

          const linkMap = new Map();
          const maxWeight = Math.max(1, ...graph.edges.map(e => e.weight || 1));
          graph.edges.forEach(e => {
            const p1 = positions.get(e.source), p2 = positions.get(e.target);
            if (!p1 || !p2) return;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y);
            line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
            line.setAttribute('class', 'graph-link');
            line.setAttribute('stroke-width', String(0.5 + 1.5 * ((e.weight || 1) / maxWeight)));
            root.appendChild(line);
            const key = e.source < e.target ? `${e.source}|${e.target}` : `${e.target}|${e.source}`;
            linkMap.set(key, line);
          });

          nodes.forEach(n => {
            const { x, y } = positions.get(n.id) || { x: cx, y: cy };
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'graph-node'); g.setAttribute('data-id', n.id);
            const r = 4 + 8 * (n.count / maxCount);
            const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            c.setAttribute('cx', x); c.setAttribute('cy', y); c.setAttribute('r', String(r));
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', String(x + r + 2)); t.setAttribute('y', String(y + 3)); t.textContent = n.id;
            g.appendChild(c); g.appendChild(t); root.appendChild(g);

            g.addEventListener('mouseenter', () => highlight(n.id));
            g.addEventListener('mouseleave', () => clear());
            g.addEventListener('click', () => navigateWithTag(n.id));
          });

          function highlight(id) {
            const neigh = new Set([id]);
            graph.edges.forEach(e => { if (e.source === id) neigh.add(e.target); if (e.target === id) neigh.add(e.source); });
            root.querySelectorAll('.graph-node').forEach(el => {
              const nid = el.getAttribute('data-id');
              const active = neigh.has(nid);
              el.classList.toggle('active', active);
              el.classList.toggle('dimmed', !active);
            });
            root.querySelectorAll('.graph-link').forEach(l => l.classList.add('dimmed'));
            graph.edges.forEach(e => {
              if (e.source === id || e.target === id || neigh.has(e.source) || neigh.has(e.target)) {
                const key = e.source < e.target ? `${e.source}|${e.target}` : `${e.target}|${e.source}`;
                const line = linkMap.get(key); if (line) line.classList.remove('dimmed');
              }
            });
          }
          function clear() {
            root.querySelectorAll('.graph-node').forEach(el => el.classList.remove('active', 'dimmed'));
            root.querySelectorAll('.graph-link').forEach(el => el.classList.remove('dimmed'));
          }

          enablePanZoom(svg, root, { autoFit: true, padding: 28 });
        })
        .catch(() => {
          const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          t.setAttribute('x', '50%'); t.setAttribute('y', '50%'); t.setAttribute('text-anchor', 'middle'); t.textContent = 'Failed to load graph.json'; t.setAttribute('class', 'graph-empty'); svg.appendChild(t);
        });
    }

    document.addEventListener('DOMContentLoaded', renderGlobalGraph);
  })();
</script>
