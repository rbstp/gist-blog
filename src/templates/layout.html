<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{title}} - rbstp.dev</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 32 32%22><rect width=%2232%22 height=%2232%22 fill=%22%23000%22 rx=%222%22/><text x=%224%22 y=%2212%22 fill=%22%2300ff00%22 font-family=%22monospace%22 font-size=%228%22>$</text><text x=%224%22 y=%2222%22 fill=%22%2300ff00%22 font-family=%22monospace%22 font-size=%226%22>_</text></svg>">
    <link rel="stylesheet" href="/styles.css?v={{timestamp}}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Inter:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="alternate" type="application/rss+xml" title="rbstp.dev RSS Feed" href="/feed.xml">
</head>

<body>
    <div class="terminal-bg"></div>
    <header>
        <nav class="container">
            <div class="logo-section">
                <span class="terminal-prompt">$</span>
                <a href="/" class="logo">rbstp.dev<span class="cursor">_</span></a>
            </div>
            <div class="nav-links">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <i class="fas fa-sun" id="theme-icon"></i>
                </button>
                <a href="/" class="nav-item">
                    <i class="fas fa-code-branch nav-icon"></i>
                    <span>main</span>
                </a>
                <a href="https://github.com/rbstp" class="nav-item" target="_blank">
                    <i class="fab fa-github nav-icon"></i>
                    <span>github</span>
                </a>
                <a href="/feed.xml" class="nav-item" target="_blank">
                    <i class="fas fa-rss nav-icon"></i>
                    <span>rss</span>
                </a>
                <a href="/graph.html" class="nav-item">
                    <i class="fas fa-project-diagram nav-icon"></i>
                    <span>graph</span>
                </a>
            </div>
        </nav>
    </header>
    <main class="container">
        {{content}}
    </main>
    <footer>
        <div class="footer-content container">
            <div class="status-bar">
                <span class="status-item">
                    <span class="status-dot online"></span>
                    <span>system: operational</span>
                </span>
                <span class="status-item">
                    <span class="status-dot"></span>
                    <span>source: <a href="https://gist.github.com/rbstp">gists</a></span>
                </span>
                <span class="status-item">
                    <span class="status-dot"></span>
                    <span>build: automated</span>
                </span>
            </div>
        </div>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        // Initialize highlight.js
        hljs.highlightAll();

        // Theme management - must run before DOMContentLoaded to prevent flash
        (function () {
            const getSystemTheme = () => window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
            const getStoredTheme = () => localStorage.getItem('theme');
            const setTheme = (theme) => {
                document.documentElement.setAttribute('data-theme', theme);
                localStorage.setItem('theme', theme);

                const themeIcon = document.getElementById('theme-icon');
                if (themeIcon) {
                    themeIcon.className = theme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
                }
            };

            // Initialize theme
            const storedTheme = getStoredTheme();
            const initialTheme = storedTheme || getSystemTheme();
            setTheme(initialTheme);

            // Listen for system theme changes
            window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                if (!getStoredTheme()) {
                    setTheme(e.matches ? 'light' : 'dark');
                }
            });

            // Theme toggle function
            window.toggleTheme = function () {
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                setTheme(newTheme);
            };
        })();

        document.addEventListener('DOMContentLoaded', function () {
            // Dev mode easter egg state
            let isDevMode = false;

            // Dev mode toggle functionality
            function initializeDevModeEasterEgg() {
                const mainButton = document.querySelector('a.nav-item[href="/"]');
                if (mainButton) {
                    mainButton.addEventListener('click', function (e) {
                        e.preventDefault();
                        toggleDevMode();
                    });
                }
            }

            function toggleDevMode() {
                isDevMode = !isDevMode;

                if (isDevMode) {
                    activateDevMode();
                } else {
                    deactivateDevMode();
                }
            }

            function activateDevMode() {
                document.body.classList.add('dev-mode');

                // Store original content for restoration
                if (!window.originalContent) {
                    window.originalContent = {
                        title: document.title,
                        buildStatus: document.querySelector('.build-status'),
                        heroTerminal: document.querySelector('.hero-terminal .terminal-body'),
                        footerStatus: document.querySelector('.status-bar'),
                        postCards: document.querySelectorAll('.post-card')
                    };
                }

                // Change page title
                document.title = 'SYSTEM FAILURE - rbstp.dev';

                // Transform build status
                const buildStatus = document.querySelector('.build-status');
                if (buildStatus) {
                    buildStatus.className = 'build-status error';
                    buildStatus.innerHTML = 'âœ— Build Failed';
                }

                // Transform hero terminal
                const heroTerminalBody = document.querySelector('.hero-terminal .terminal-body');
                if (heroTerminalBody) {
                    heroTerminalBody.innerHTML = `
                        <div class="terminal-line">
                            <span class="prompt">rbstp@devops:~$</span>
                            <span class="command">deploy --production</span>
                        </div>
                        <div class="terminal-output error-output">
                            <span class="output-text error">ERROR: Deployment failed at 2025-07-30T15:42:31Z</span>
                        </div>
                        <div class="terminal-output error-output">
                            <span class="output-text error">CRITICAL: Database connection lost</span>
                        </div>
                        <div class="terminal-line">
                            <span class="prompt">rbstp@devops:~$</span>
                            <span class="command">rollback --emergency</span>
                        </div>
                        <div class="terminal-output error-output">
                            <span class="output-text warning">INITIATING EMERGENCY ROLLBACK...</span>
                        </div>
                        <div class="terminal-output error-output">
                            <span class="output-text error">47 services affected</span>
                        </div>
                    `;
                }

                // Transform footer status
                const footerStatus = document.querySelector('.status-bar');
                if (footerStatus) {
                    footerStatus.innerHTML = `
                        <span class="status-item">
                            <span class="status-dot error"></span>
                            <span>system: degraded</span>
                        </span>
                        <span class="status-item">
                            <span class="status-dot error"></span>
                            <span>alerts: <a href="#" style="color: var(--accent-error);">47 active</a></span>
                        </span>
                        <span class="status-item">
                            <span class="status-dot warning"></span>
                            <span>rollback: in progress</span>
                        </span>
                    `;
                }

                // Transform post cards
                const postCards = document.querySelectorAll('.post-card');
                postCards.forEach(card => {
                    const statusIndicator = card.querySelector('.status-indicator');
                    const statusText = card.querySelector('.status-text');
                    const branchName = card.querySelector('.branch-name');

                    if (statusIndicator) {
                        statusIndicator.className = 'status-indicator error';
                    }
                    if (statusText) {
                        statusText.textContent = 'failed';
                        statusText.style.color = 'var(--accent-error)';
                    }
                    if (branchName) {
                        branchName.textContent = 'dev';
                    }
                });

                // Update section header
                const sectionTitle = document.querySelector('.section-title');
                if (sectionTitle) {
                    sectionTitle.textContent = 'Failed Deployments';
                }

                // Update pipeline status 
                const pipelineStatus = document.querySelector('.pipeline-status');
                if (pipelineStatus) {
                    pipelineStatus.innerHTML = `
                        <span class="build-status error">âœ— Build Failed</span>
                        <span class="deploy-time">Last failure: <span class="local-time">2 min ago</span></span>
                    `;
                }

                // Update main branch button text
                const mainButton = document.querySelector('a.nav-item[href="/"] span');
                if (mainButton) {
                    mainButton.textContent = 'dev';
                }
            }

            function deactivateDevMode() {
                document.body.classList.remove('dev-mode');

                if (window.originalContent) {
                    // Restore original content
                    document.title = window.originalContent.title;

                    // Simply reload the page to restore everything properly
                    window.location.reload();
                }
            }

            // Theme toggle button
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                themeToggle.addEventListener('click', window.toggleTheme);
            }

            // Initialize dev mode easter egg
            initializeDevModeEasterEgg();
            // Convert timestamps to local time
            const timeElements = document.querySelectorAll('.local-time');
            timeElements.forEach(function (element) {
                const timestamp = element.getAttribute('data-timestamp');
                if (timestamp) {
                    const date = new Date(timestamp);
                    const options = {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    };
                    element.textContent = date.toLocaleString('en-US', options);
                }
            });

            // Client-side pagination and filtering system (index page only)
            const section = document.querySelector('.pipeline-section');
            const isIndexPage = !!section;
            let currentPage = 1;
            let activeTags = [];
            let allPosts = [];
            let paginationSection = null, paginationCommand = null, paginationPages = null, prevBtn = null, nextBtn = null, filterStatus = null;

            if (isIndexPage) {
                const POSTS_PER_PAGE = 6;
                allPosts = Array.from(document.querySelectorAll('.post-card'));
                paginationSection = document.getElementById('pagination-section');
                paginationCommand = document.getElementById('pagination-command');
                paginationPages = document.getElementById('pagination-pages');
                prevBtn = document.getElementById('prev-btn');
                nextBtn = document.getElementById('next-btn');

                // Create filter status display
                filterStatus = document.createElement('div');
                filterStatus.className = 'filter-status';
                filterStatus.style.display = 'none';
                section.insertBefore(filterStatus, section.querySelector('.posts-grid'));
            }

            function getFilteredPosts() {
                if (!isIndexPage) return [];
                if (activeTags.length === 0) return allPosts;

                return allPosts.filter(function (post) {
                    const postTags = post.querySelectorAll('.tag');
                    const postTagNames = Array.from(postTags).map(function (tag) {
                        return tag.getAttribute('data-tag');
                    });

                    // Post must have ALL selected tags (AND logic)
                    return activeTags.every(function (activeTag) {
                        return postTagNames.includes(activeTag);
                    });
                });
            }

            function updatePagination() {
                if (!isIndexPage) return;
                const filteredPosts = getFilteredPosts();
                const POSTS_PER_PAGE = 6;
                const totalPages = Math.ceil(filteredPosts.length / POSTS_PER_PAGE);

                // Hide all posts first
                allPosts.forEach(function (post) {
                    post.style.display = 'none';
                });

                // Show posts for current page
                const startIndex = (currentPage - 1) * POSTS_PER_PAGE;
                const endIndex = startIndex + POSTS_PER_PAGE;
                const postsToShow = filteredPosts.slice(startIndex, endIndex);

                postsToShow.forEach(function (post) {
                    post.style.display = 'block';
                });

                // Update pagination controls
                // Show pagination if more than 1 page OR if filtering is active (to keep tag controls accessible)
                if (paginationSection && (totalPages > 1 || activeTags.length > 0)) {
                    paginationSection.style.display = 'block';

                    // Update command
                    if (paginationCommand) {
                        if (totalPages > 1) {
                            paginationCommand.textContent = 'ls posts | less :' + currentPage + '/' + totalPages;
                        } else {
                            paginationCommand.textContent = 'ls posts | head -' + filteredPosts.length;
                        }
                    }

                    // Update prev/next buttons - hide if only one page
                    if (prevBtn) {
                        if (totalPages > 1) {
                            prevBtn.style.display = 'flex';
                            prevBtn.disabled = currentPage === 1;
                        } else {
                            prevBtn.style.display = 'none';
                        }
                    }
                    if (nextBtn) {
                        if (totalPages > 1) {
                            nextBtn.style.display = 'flex';
                            nextBtn.disabled = currentPage === totalPages;
                        } else {
                            nextBtn.style.display = 'none';
                        }
                    }

                    // Update page numbers - hide if only one page
                    if (paginationPages) {
                        if (totalPages > 1) {
                            paginationPages.style.display = 'flex';
                            paginationPages.innerHTML = '';
                            const maxVisible = 5;
                            let startPage = Math.max(1, currentPage - Math.floor(maxVisible / 2));
                            let endPage = Math.min(totalPages, startPage + maxVisible - 1);

                            if (endPage - startPage + 1 < maxVisible) {
                                startPage = Math.max(1, endPage - maxVisible + 1);
                            }

                            for (let i = startPage; i <= endPage; i++) {
                                const pageBtn = document.createElement('button');
                                pageBtn.className = 'pagination-page' + (i === currentPage ? ' current' : '');
                                pageBtn.textContent = i;
                                pageBtn.addEventListener('click', function () {
                                    currentPage = i;
                                    updatePagination();
                                });
                                paginationPages.appendChild(pageBtn);
                            }
                        } else {
                            paginationPages.style.display = 'none';
                        }
                    }
                } else if (paginationSection) {
                    paginationSection.style.display = 'none';
                }
            }

            function updateFilterStatus() {
                if (!isIndexPage) return;
                if (activeTags.length === 0) {
                    filterStatus.style.display = 'none';
                    return;
                }

                const filteredCount = getFilteredPosts().length;
                const tagsDisplay = activeTags.map(function (tag) {
                    return '<span class="filter-tag clickable-filter-tag" data-tag="' + tag + '">#' + tag + '</span>';
                }).join(' ');

                filterStatus.innerHTML =
                    '<div class="filter-info">' +
                    '<span class="filter-prompt">$</span>' +
                    '<span>grep --tag</span>' +
                    tagsDisplay +
                    '<span class="filter-count">â†’ ' + filteredCount + ' result' + (filteredCount !== 1 ? 's' : '') + '</span>' +
                    '<button class="clear-filter" onclick="clearFilter()">clear</button>' +
                    '</div>';
                filterStatus.style.display = 'block';

                // Add click listeners to filter status tags
                const clickableFilterTags = filterStatus.querySelectorAll('.clickable-filter-tag');
                clickableFilterTags.forEach(function (filterTag) {
                    filterTag.addEventListener('click', function () {
                        const tagName = this.getAttribute('data-tag');
                        const tagIndex = activeTags.indexOf(tagName);

                        if (tagIndex > -1) {
                            // Remove this tag from filter
                            activeTags.splice(tagIndex, 1);

                            // Update all tag elements with this tag to remove active class
                            const allTagElements = document.querySelectorAll('.tag');
                            allTagElements.forEach(function (t) {
                                if (t.getAttribute('data-tag') === tagName) {
                                    t.classList.remove('active');
                                }
                            });

                            currentPage = 1;
                            updateFilterStatus();
                            updatePagination();
                        }
                    });
                });
            }

            // Global function for clear button
            window.clearFilter = function () {
                activeTags = [];
                currentPage = 1;
                const allTagElements = document.querySelectorAll('.tag');
                allTagElements.forEach(function (tag) {
                    tag.classList.remove('active');
                });
                updateFilterStatus();
                updatePagination();
            };

            // Tag filtering (including pagination tags)
            const allTagElements = document.querySelectorAll('.tag');
            if (isIndexPage) {
                allTagElements.forEach(function (tag) {
                    tag.addEventListener('click', function () {
                        const tagName = this.getAttribute('data-tag');
                        const tagIndex = activeTags.indexOf(tagName);

                        if (tagIndex > -1) {
                            // Remove tag from filter
                            activeTags.splice(tagIndex, 1);
                            // Update all elements with this tag to remove active class
                            allTagElements.forEach(function (t) {
                                if (t.getAttribute('data-tag') === tagName) {
                                    t.classList.remove('active');
                                }
                            });
                        } else {
                            // Add tag to filter
                            activeTags.push(tagName);
                            // Update all elements with this tag to add active class
                            allTagElements.forEach(function (t) {
                                if (t.getAttribute('data-tag') === tagName) {
                                    t.classList.add('active');
                                }
                            });
                        }

                        currentPage = 1; // Reset to first page when filtering changes
                        updateFilterStatus();
                        updatePagination();
                    });
                });
            }

            // Pagination controls
            if (isIndexPage && prevBtn) {
                prevBtn.addEventListener('click', function () {
                    if (currentPage > 1) {
                        currentPage--;
                        updatePagination();
                    }
                });
            }

            if (isIndexPage && nextBtn) {
                nextBtn.addEventListener('click', function () {
                    const filteredPosts = getFilteredPosts();
                    const POSTS_PER_PAGE = 6;
                    const totalPages = Math.ceil(filteredPosts.length / POSTS_PER_PAGE);
                    if (currentPage < totalPages) {
                        currentPage++;
                        updatePagination();
                    }
                });
            }

            // Terminal control functionality
            function setupTerminalControls() {
                const terminals = document.querySelectorAll('.hero-terminal, .pagination-section');

                terminals.forEach(function (terminal) {
                    const closeBtn = terminal.querySelector('.control.close');
                    const minimizeBtn = terminal.querySelector('.control.minimize');
                    const maximizeBtn = terminal.querySelector('.control.maximize');
                    const terminalWindow = terminal.querySelector('.terminal-window, .pagination-terminal');

                    // Close button - hide the entire section
                    if (closeBtn) {
                        closeBtn.style.cursor = 'pointer';
                        closeBtn.addEventListener('click', function () {
                            terminal.style.display = 'none';
                        });
                    }

                    // Minimize button - collapse to header only
                    if (minimizeBtn && terminalWindow) {
                        minimizeBtn.style.cursor = 'pointer';
                        minimizeBtn.addEventListener('click', function () {
                            const body = terminalWindow.querySelector('.terminal-body, .pagination-body');
                            if (body) {
                                if (terminalWindow.dataset.minimized === 'true') {
                                    // Restore
                                    body.style.display = 'block';
                                    terminalWindow.dataset.minimized = 'false';
                                } else {
                                    // Minimize
                                    body.style.display = 'none';
                                    terminalWindow.dataset.minimized = 'true';
                                }
                            }
                        });
                    }

                    // Maximize button - toggle full width
                    if (maximizeBtn && terminalWindow) {
                        maximizeBtn.style.cursor = 'pointer';
                        maximizeBtn.addEventListener('click', function () {
                            const tagsSection = terminal.querySelector('#pagination-tags-section');
                            const heroExpanded = terminal.querySelector('#hero-terminal-expanded');

                            if (terminalWindow.dataset.maximized === 'true') {
                                // Restore
                                terminalWindow.style.width = '';
                                terminalWindow.style.maxWidth = '';
                                terminalWindow.dataset.maximized = 'false';

                                // Hide tags section when not maximized
                                if (tagsSection) {
                                    tagsSection.style.display = 'none';
                                }

                                // Hide hero terminal expanded content when not maximized
                                if (heroExpanded) {
                                    heroExpanded.style.display = 'none';
                                }
                            } else {
                                // Maximize
                                terminalWindow.style.width = '100%';
                                terminalWindow.style.maxWidth = 'none';
                                terminalWindow.dataset.maximized = 'true';

                                // Show tags section when maximized
                                if (tagsSection) {
                                    tagsSection.style.display = 'block';
                                }

                                // Show hero terminal expanded content when maximized
                                if (heroExpanded) {
                                    heroExpanded.style.display = 'block';
                                }
                            }
                        });
                    }
                });
            }

            // ToC active section highlighting
            function setupTocActiveHighlighting() {
                const tocLinks = document.querySelectorAll('.toc-link');
                if (!tocLinks.length) return;

                const headings = Array.from(document.querySelectorAll('h2[id], h3[id], h4[id], h5[id], h6[id]'));
                if (!headings.length) return;

                const sidebar = document.querySelector('.toc-sidebar');

                function ensureVisible(link, center = false) {
                    if (!sidebar || !link) return;
                    // Only adjust when it's actually out of view to avoid fighting page scroll
                    const sbRect = sidebar.getBoundingClientRect();
                    const lRect = link.getBoundingClientRect();
                    const margin = 8; // small visual buffer
                    if (center) {
                        const sbCenter = (sbRect.top + sbRect.bottom) / 2;
                        const lCenter = (lRect.top + lRect.bottom) / 2;
                        sidebar.scrollTop += (lCenter - sbCenter);
                    } else if (lRect.top < sbRect.top + margin) {
                        sidebar.scrollTop -= (sbRect.top + margin) - lRect.top;
                    } else if (lRect.bottom > sbRect.bottom - margin) {
                        sidebar.scrollTop += lRect.bottom - (sbRect.bottom - margin);
                    }
                }

                let lastScrollY = window.scrollY;
                function updateActiveLink() {
                    const scrollPosition = window.scrollY + 100; // Offset for header

                    let activeHeading = null;
                    for (const heading of headings) {
                        if (heading.offsetTop <= scrollPosition) {
                            activeHeading = heading;
                        } else {
                            break;
                        }
                    }

                    // Remove active class from all links
                    tocLinks.forEach(link => link.classList.remove('active'));

                    // Add active class to current section
                    if (activeHeading) {
                        const activeLink = document.querySelector(`.toc-link[href="#${activeHeading.id}"]`);
                        if (activeLink) {
                            activeLink.classList.add('active');
                            const scrollingUp = window.scrollY < lastScrollY;
                            // On upward scroll, center the active item; on downward, just ensure visible
                            ensureVisible(activeLink, scrollingUp);

                            // If scrolling down and we're on the last ToC item, snap to the very bottom
                            if (!scrollingUp && sidebar) {
                                const linksArr = Array.from(tocLinks);
                                const idx = linksArr.indexOf(activeLink);
                                if (idx === linksArr.length - 1) {
                                    // Snap to bottom and ensure the ToC terminal rounded corner is fully visible
                                    const tocTerminal = document.querySelector('.toc-terminal');
                                    const sbRect = sidebar.getBoundingClientRect();
                                    const margin = 8;
                                    // First try snapping to the absolute bottom
                                    sidebar.scrollTop = sidebar.scrollHeight;
                                    if (tocTerminal) {
                                        const tRect = tocTerminal.getBoundingClientRect();
                                        if (tRect.bottom > sbRect.bottom - margin) {
                                            const delta = tRect.bottom - (sbRect.bottom - margin);
                                            sidebar.scrollTop += Math.max(0, delta);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    lastScrollY = window.scrollY;
                }

                // Update on scroll with throttling
                let ticking = false;
                function throttledUpdate() {
                    if (!ticking) {
                        requestAnimationFrame(() => {
                            updateActiveLink();
                            ticking = false;
                        });
                        ticking = true;
                    }
                }

                window.addEventListener('scroll', throttledUpdate);
                updateActiveLink(); // Initial call
            }

            // Initial load
            if (isIndexPage) updatePagination();
            setupTerminalControls();
            setupTocActiveHighlighting();

            // Position the sidebar below the header with equal gaps
            function adjustTocSidebar() {
                const sidebar = document.querySelector('.toc-sidebar');
                const header = document.querySelector('header');
                if (!sidebar) return;
                const gap = 16; // 1rem in px
                // Try to align the sidebar to the right edge of the main content container
                const container = document.querySelector('main.container');
                const headerRect = header ? header.getBoundingClientRect() : null;
                const headerBottom = headerRect ? Math.ceil(headerRect.bottom) : 0; // distance from viewport top
                // Use the actual bottom position so the sidebar slides up smoothly as the header scrolls out
                const top = Math.max(gap, headerBottom + gap);
                sidebar.style.top = top + 'px';
                // keep a 1rem bottom gap
                let maxH = Math.max(120, window.innerHeight - top - gap);

                // If footer is entering the viewport, reduce height so the sidebar doesn't overlap it
                const footer = document.querySelector('footer');
                if (footer) {
                    const fRect = footer.getBoundingClientRect();
                    // When footer top is inside viewport, clamp max height so sidebar bottom stays above footer
                    if (fRect.top < window.innerHeight) {
                        const available = Math.max(80, fRect.top - top - gap);
                        maxH = Math.max(80, Math.min(maxH, available));
                    }
                }
                sidebar.style.maxHeight = maxH + 'px';

                // Responsive width and positioning: prefer aligning with container; if not enough room,
                // dock to viewport right and reserve space by increasing post container's right margin.
                if (container) {
                    const cRect = container.getBoundingClientRect();
                    const postContainer = document.querySelector('.post-container');
                    const availableRight = Math.max(0, window.innerWidth - cRect.right - gap);
                    const minW = 240;
                    const maxW = 360;
                    const ideal = Math.round(Math.min(maxW, Math.max(minW, window.innerWidth * 0.22)));
                    const fitWidth = Math.max(minW, Math.min(ideal, availableRight));

                    // Reset any reserved space by default; we'll add it only for the fallback case
                    if (postContainer) postContainer.style.marginRight = '';

                    if (availableRight >= minW + 4) {
                        // Enough room to align next to the container's right edge
                        sidebar.style.display = 'block';
                        sidebar.style.right = 'auto';
                        sidebar.style.left = Math.max(gap, Math.min(cRect.right + gap, window.innerWidth - fitWidth - gap)) + 'px';
                        sidebar.style.width = fitWidth + 'px';
                        sidebar.style.minWidth = minW + 'px';
                        sidebar.style.maxWidth = maxW + 'px';
                    } else {
                        // Fallback: dock to viewport right and reserve space by pushing content slightly left
                        const fallbackWidth = Math.round(Math.min(maxW, Math.max(220, ideal)));
                        // Only use fallback when viewport is reasonably wide
                        if (window.innerWidth >= 1160) {
                            sidebar.style.display = 'block';
                            sidebar.style.left = '';
                            sidebar.style.right = gap + 'px';
                            sidebar.style.width = fallbackWidth + 'px';
                            sidebar.style.minWidth = '220px';
                            sidebar.style.maxWidth = maxW + 'px';
                            if (postContainer) postContainer.style.marginRight = (fallbackWidth + gap) + 'px';
                        } else {
                            // Truly narrow viewport â€” hide
                            sidebar.style.display = 'none';
                        }
                    }
                }

                // If the page is scrolled back to very top, ensure the sidebar scroll position resets
                if ((window.scrollY || document.documentElement.scrollTop || 0) <= 2) {
                    sidebar.scrollTop = 0;
                }
            }
            adjustTocSidebar();
            window.addEventListener('resize', adjustTocSidebar, { passive: true });
            // Also respond to scroll so the gap reduces as the header goes off-screen
            window.addEventListener('scroll', adjustTocSidebar, { passive: true });

            // Initialize topic graph when sidebar exists (on post pages)
            initTopicGraph();

            // Apply preselected tags on index if any
            if (isIndexPage) applyPreselectedTags();
        });

        // Minimalist interactive tag graph
        function initTopicGraph() {
            const svg = document.getElementById('topic-graph');
            if (!svg) return; // not on post page
            const container = svg.parentElement;
            const currentTopic = (container && container.getAttribute('data-current-topic')) ? container.getAttribute('data-current-topic') : '';
            // Read all topics for this post (CSV), used to color topic nodes
            const allTopicsCsv = container && container.getAttribute('data-all-topics');
            const topicsSet = new Set((allTopicsCsv || '')
                .split(',')
                .map(s => s.trim().toLowerCase())
                .filter(Boolean));

            fetch('/graph.json?v={{timestamp}}')
                .then(r => r.ok ? r.json() : null)
                .then(graph => {
                    if (!graph || !graph.nodes) { console.warn('topic-graph: no graph data'); return; }

                    const width = 220, height = 232, cx = width / 2, cy = height / 2;
                    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                    while (svg.firstChild) svg.removeChild(svg.firstChild);

                    // Root group for pan/zoom
                    const root = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    root.setAttribute('id', 'graph-root');
                    svg.appendChild(root);

                    if (graph.nodes.length === 0) {
                        console.warn('topic-graph: empty nodes array');
                        const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        t.setAttribute('x', String(cx));
                        t.setAttribute('y', String(cy));
                        t.setAttribute('text-anchor', 'middle');
                        t.textContent = 'No topics';
                        t.setAttribute('class', 'graph-empty');
                        svg.appendChild(t);
                        return;
                    }

                    // Build adjacency
                    const neighbors = new Map();
                    graph.nodes.forEach(n => neighbors.set(n.id, new Set()));
                    graph.edges.forEach(e => {
                        neighbors.get(e.source)?.add(e.target);
                        neighbors.get(e.target)?.add(e.source);
                    });

                    // Focus mode: center the current topic, arrange only its neighbors around it
                    const centerId = currentTopic && neighbors.has(currentTopic) ? currentTopic : (graph.nodes[0]?.id || '');
                    const neighborIds = Array.from(neighbors.get(centerId) || []);
                    const visibleIds = [centerId, ...neighborIds];
                    const visibleSet = new Set(visibleIds);

                    const nodesPos = new Map();
                    // Center node
                    nodesPos.set(centerId, { x: cx, y: cy });
                    // Arrange neighbors on a circle
                    const radius = 70;
                    neighborIds.forEach((id, i) => {
                        const angle = (i / Math.max(1, neighborIds.length)) * Math.PI * 2 - Math.PI / 2;
                        nodesPos.set(id, { x: cx + radius * Math.cos(angle), y: cy + radius * Math.sin(angle) });
                    });

                    // Draw links and keep a map for highlighting
                    const maxWeight = Math.max(1, ...graph.edges.map(e => e.weight || 1));
                    const linkMap = new Map(); // key: a|b sorted -> line
                    const visibleEdges = graph.edges.filter(e => visibleSet.has(e.source) && visibleSet.has(e.target));
                    visibleEdges.forEach(e => {
                        const p1 = nodesPos.get(e.source);
                        const p2 = nodesPos.get(e.target);
                        if (!p1 || !p2) return;
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', p1.x);
                        line.setAttribute('y1', p1.y);
                        line.setAttribute('x2', p2.x);
                        line.setAttribute('y2', p2.y);
                        const opacity = 0.2 + 0.6 * (e.weight / maxWeight);
                        line.setAttribute('class', 'graph-link');
                        line.setAttribute('stroke-width', String(0.5 + 1.5 * (e.weight / maxWeight)));
                        line.setAttribute('stroke-opacity', String(opacity));
                        root.appendChild(line);
                        const key = e.source < e.target ? `${e.source}|${e.target}` : `${e.target}|${e.source}`;
                        linkMap.set(key, line);
                    });

                    // Draw nodes with labels
                    const maxCount = Math.max(1, ...graph.nodes.map(n => n.count));
                    visibleIds.forEach(nid => {
                        const n = graph.nodes.find(nn => nn.id === nid) || { id: nid, count: 1 };
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.setAttribute('class', 'graph-node');
                        g.setAttribute('data-id', n.id);
                        if (topicsSet.has(n.id)) {
                            g.classList.add('topic');
                        }
                        const { x, y } = nodesPos.get(n.id);
                        const r = 3 + 6 * (n.count / maxCount);
                        const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        c.setAttribute('cx', x);
                        c.setAttribute('cy', y);
                        c.setAttribute('r', String(r));
                        // Use CSS for fill color to match theme

                        const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        t.setAttribute('x', String(x + r + 2));
                        t.setAttribute('y', String(y + 3));
                        t.textContent = n.id;

                        g.appendChild(c);
                        g.appendChild(t);
                        root.appendChild(g);

                        // Interactions
                        g.addEventListener('mouseenter', () => setHighlight(n.id));
                        g.addEventListener('mouseleave', () => clearHighlight());
                        if (n.id !== centerId) {
                            g.addEventListener('click', () => navigateWithTag(n.id));
                        }
                    });

                    function setHighlight(id) {
                        const neighborSet = neighbors.get(id) || new Set();
                        const groups = root.querySelectorAll('.graph-node');
                        const links = root.querySelectorAll('.graph-link');
                        groups.forEach(el => {
                            const nid = el.getAttribute('data-id');
                            const active = nid === id || neighborSet.has(nid);
                            el.classList.toggle('active', active);
                            el.classList.toggle('dimmed', !active);
                        });
                        links.forEach(l => { l.classList.add('dimmed'); });
                        // Undim links that connect active nodes (using linkMap for lookup)
                        visibleEdges.forEach(e => {
                            if (e.source === id || e.target === id || neighborSet.has(e.source) || neighborSet.has(e.target)) {
                                const key = e.source < e.target ? `${e.source}|${e.target}` : `${e.target}|${e.source}`;
                                const line = linkMap.get(key);
                                if (line) line.classList.remove('dimmed');
                            }
                        });
                    }

                    function clearHighlight() {
                        root.querySelectorAll('.graph-node').forEach(el => {
                            el.classList.remove('active', 'dimmed');
                        });
                        root.querySelectorAll('.graph-link').forEach(el => el.classList.remove('dimmed'));
                    }

                    function navigateWithTag(tag) {
                        try {
                            localStorage.setItem('preselectedTags', JSON.stringify([tag]));
                        } catch { }
                        window.location.href = '/';
                    }
                    // Enable simple pan/zoom
                    enablePanZoom(svg, root);
                })
                .catch((e) => { console.warn('topic-graph: failed to load graph.json', e); });
        }

        // Simple pan/zoom on SVG group
        function enablePanZoom(svg, root) {
            let scale = 1;
            let tx = 0, ty = 0;
            let panning = false;
            let lastX = 0, lastY = 0;

            function apply() {
                root.setAttribute('transform', `translate(${tx},${ty}) scale(${scale})`);
            }

            svg.addEventListener('wheel', (e) => {
                e.preventDefault();
                const factor = e.deltaY < 0 ? 1.1 : 0.9;
                const old = scale;
                const next = Math.max(0.6, Math.min(2.5, old * factor));
                if (next === old) return;
                // Zoom towards pointer: compute cursor in SVG viewBox units
                const rect = svg.getBoundingClientRect();
                const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : { x: 0, y: 0, width: svg.width.baseVal.value, height: svg.height.baseVal.value };
                const px = vb.x + ((e.clientX - rect.left) / rect.width) * vb.width;
                const py = vb.y + ((e.clientY - rect.top) / rect.height) * vb.height;
                // Adjust translation so the point under the cursor stays fixed
                tx = tx + px * (1 / next - 1 / old);
                ty = ty + py * (1 / next - 1 / old);
                scale = next;
                apply();
            }, { passive: false });

            svg.addEventListener('pointerdown', (e) => {
                panning = true;
                lastX = e.clientX;
                lastY = e.clientY;
                svg.classList.add('panning');
            });
            svg.addEventListener('pointermove', (e) => {
                if (!panning) return;
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;
                tx += dx;
                ty += dy;
                apply();
            });
            const stop = () => { panning = false; svg.classList.remove('panning'); };
            svg.addEventListener('pointerup', stop);
            svg.addEventListener('pointerleave', stop);
            apply();
        }

        // Read preselectedTags and apply to index filter
        function applyPreselectedTags() {
            const section = document.querySelector('.pipeline-section');
            if (!section) return; // not on index
            let preload = null;
            try {
                preload = JSON.parse(localStorage.getItem('preselectedTags') || 'null');
            } catch { preload = null; }
            if (!Array.isArray(preload) || preload.length === 0) return;

            // Set active tags
            const set = new Set(preload);
            const allTags = document.querySelectorAll('.tag');
            allTags.forEach(t => {
                const name = t.getAttribute('data-tag');
                if (set.has(name)) {
                    t.classList.add('active');
                }
            });
            // Trigger the existing filtering code by simulating clicks for each tag (to update state)
            preload.forEach(name => {
                const el = Array.from(allTags).find(e => e.getAttribute('data-tag') === name);
                if (el) el.click();
            });
            try { localStorage.removeItem('preselectedTags'); } catch { }
        }
    </script>
</body>

</html>
